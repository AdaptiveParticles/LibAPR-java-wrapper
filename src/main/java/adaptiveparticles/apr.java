// Targeted by JavaCPP version 1.4.1: DO NOT EDIT THIS FILE

package adaptiveparticles;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class apr extends adaptiveparticles.wrapper.helper.AprLibHelper {
    static { Loader.load(); }

@Name("std::vector<MapIterator>") public static class MapIteratorVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MapIteratorVector(Pointer p) { super(p); }
    public MapIteratorVector(MapIterator value) { this(1); put(0, value); }
    public MapIteratorVector(MapIterator ... array) { this(array.length); put(array); }
    public MapIteratorVector()       { allocate();  }
    public MapIteratorVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef MapIteratorVector put(@ByRef MapIteratorVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef MapIterator get(@Cast("size_t") long i);
    public native MapIteratorVector put(@Cast("size_t") long i, MapIterator value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const MapIterator get();
    }

    public MapIterator[] get() {
        MapIterator[] array = new MapIterator[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public MapIterator pop_back() {
        long size = size();
        MapIterator value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public MapIteratorVector push_back(MapIterator value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public MapIteratorVector put(MapIterator value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public MapIteratorVector put(MapIterator ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

// Parsed from APR.h

// #ifndef __APR_H__
// #define __APR_H__

// #include "data_structures/APR/APR.hpp"
// #include "numerics/APRTreeNumerics.hpp"
// #include <cstdint>
// #include <iostream>

public static class AprBasicOps extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public AprBasicOps() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AprBasicOps(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AprBasicOps(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public AprBasicOps position(long position) {
        return (AprBasicOps)super.position(position);
    }

    public native void read(@StdString BytePointer aAprFileName);
    public native void read(@StdString String aAprFileName);

    // Default values for min/max will reconstruct whole image
    public native void reconstruct(int x_min/*=0*/, int x_max/*=-2*/, int y_min/*=0*/, int y_max/*=-2*/, int z_min/*=0*/, int z_max/*=-2*/);
    public native void reconstruct();

    public native void reconstructToBuffer(int x, int y, int z, int width, int height, int depth, int level, @Cast("uint16_t*") ShortPointer buffer);
    public native void reconstructToBuffer(int x, int y, int z, int width, int height, int depth, int level, @Cast("uint16_t*") ShortBuffer buffer);
    public native void reconstructToBuffer(int x, int y, int z, int width, int height, int depth, int level, @Cast("uint16_t*") short[] buffer);

    public native AprBasicOps get16bitUnsignedAPRInternal(int width, int height, int depth, int bpp, @Cast("uint16_t*") ShortPointer buffer);
    public native AprBasicOps get16bitUnsignedAPRInternal(int width, int height, int depth, int bpp, @Cast("uint16_t*") ShortBuffer buffer);
    public native AprBasicOps get16bitUnsignedAPRInternal(int width, int height, int depth, int bpp, @Cast("uint16_t*") short[] buffer);

    public native ShortPointer data();

    public native int height();
    public native int width();
    public native int depth();

    public native void saveAPR(@StdString BytePointer aDirectory, @StdString BytePointer aFileName);
    public native void saveAPR(@StdString String aDirectory, @StdString String aFileName);

    public native @ByVal APRIterator iterator();

}

// #endif //__APR_H__


// Parsed from algorithm/APRParameters.hpp

//
// Created by cheesema on 08.01.18.
//

// #ifndef PARTPLAY_APR_PARAMETERS_HPP
// #define PARTPLAY_APR_PARAMETERS_HPP

// #include <string>
// #include <iostream>

public static class APRParameters extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public APRParameters() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public APRParameters(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public APRParameters(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public APRParameters position(long position) {
        return (APRParameters)super.position(position);
    }


    // pixel spacing
    public native float dx(); public native APRParameters dx(float dx);
    public native float dy(); public native APRParameters dy(float dy);
    public native float dz(); public native APRParameters dz(float dz);

    // window size set for Local Intensity Scale
    public native float psfx(); public native APRParameters psfx(float psfx);
    public native float psfy(); public native APRParameters psfy(float psfy);
    public native float psfz(); public native APRParameters psfz(float psfz);

    public native float Ip_th(); public native APRParameters Ip_th(float Ip_th);
    public native float SNR_min(); public native APRParameters SNR_min(float SNR_min);
    public native float lambda(); public native APRParameters lambda(float lambda);
    public native float min_signal(); public native APRParameters min_signal(float min_signal);
    public native float rel_error(); public native APRParameters rel_error(float rel_error);

    public native float sigma_th(); public native APRParameters sigma_th(float sigma_th);
    public native float sigma_th_max(); public native APRParameters sigma_th_max(float sigma_th_max);

    public native float noise_sd_estimate(); public native APRParameters noise_sd_estimate(float noise_sd_estimate);
    public native float background_intensity_estimate(); public native APRParameters background_intensity_estimate(float background_intensity_estimate);

    public native @Cast("bool") boolean auto_parameters(); public native APRParameters auto_parameters(boolean auto_parameters);

    public native @Cast("bool") boolean normalized_input(); public native APRParameters normalized_input(boolean normalized_input);

    public native @Cast("bool") boolean neighborhood_optimization(); public native APRParameters neighborhood_optimization(boolean neighborhood_optimization);

    public native @Cast("bool") boolean output_steps(); public native APRParameters output_steps(boolean output_steps);

    public native @StdString BytePointer name(); public native APRParameters name(BytePointer name);
    public native @StdString BytePointer output_dir(); public native APRParameters output_dir(BytePointer output_dir);
    public native @StdString BytePointer input_image_name(); public native APRParameters input_image_name(BytePointer input_image_name);
    public native @StdString BytePointer input_dir(); public native APRParameters input_dir(BytePointer input_dir);
    public native @StdString BytePointer mask_file(); public native APRParameters mask_file(BytePointer mask_file);

    
}


// #endif //PARTPLAY_APR_PARAMETERS_HPP


// Parsed from data_structures/APR/APRAccessStructures.hpp

// #ifndef __APR_ACCESSS_STRUCTURES__
// #define __APR_ACCESSS_STRUCTURES__

// #include <map>
// #include <vector>

public static class ParticleCell extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ParticleCell() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ParticleCell(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParticleCell(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ParticleCell position(long position) {
        return (ParticleCell)super.position(position);
    }

    public native @Cast("uint16_t") short x(); public native ParticleCell x(short x);
    public native @Cast("uint16_t") short y(); public native ParticleCell y(short y);
    public native @Cast("uint16_t") short z(); public native ParticleCell z(short z);
    public native @Cast("uint16_t") short level(); public native ParticleCell level(short level);
    public native @Cast("uint16_t") short type(); public native ParticleCell type(short type);
    public native @Cast("uint64_t") long pc_offset(); public native ParticleCell pc_offset(long pc_offset);
    public native @Cast("uint64_t") long global_index(); public native ParticleCell global_index(long global_index);
}

public static class YGap_map extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public YGap_map() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public YGap_map(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public YGap_map(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public YGap_map position(long position) {
        return (YGap_map)super.position(position);
    }

    public native @Cast("uint16_t") short y_end(); public native YGap_map y_end(short y_end);
    public native @Cast("uint16_t") short global_index_begin_offset(); public native YGap_map global_index_begin_offset(short global_index_begin_offset);
}

public static class ParticleCellGapMap extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ParticleCellGapMap() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ParticleCellGapMap(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParticleCellGapMap(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ParticleCellGapMap position(long position) {
        return (ParticleCellGapMap)super.position(position);
    }

}

public static class MapIterator extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public MapIterator() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public MapIterator(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MapIterator(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public MapIterator position(long position) {
        return (MapIterator)super.position(position);
    }

    public native @Cast("uint64_t") long pc_offset(); public native MapIterator pc_offset(long pc_offset);
    public native @Cast("uint16_t") short level(); public native MapIterator level(short level);
    public native @Cast("uint16_t") short max_offset(); public native MapIterator max_offset(short max_offset);
    public native @Cast("uint64_t") long global_offset(); public native MapIterator global_offset(long global_offset);
}

@NoOffset public static class LocalMapIterators extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LocalMapIterators(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LocalMapIterators(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public LocalMapIterators position(long position) {
        return (LocalMapIterators)super.position(position);
    }

    public native @ByRef MapIteratorVector same_level(); public native LocalMapIterators same_level(MapIteratorVector same_level);
    public native @StdVector MapIteratorVector child_level(); public native LocalMapIterators child_level(MapIteratorVector child_level);
    public native @ByRef MapIteratorVector parent_level(); public native LocalMapIterators parent_level(MapIteratorVector parent_level);

    public LocalMapIterators() { super((Pointer)null); allocate(); }
    private native void allocate();
}

public static class MapStorageData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public MapStorageData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public MapStorageData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MapStorageData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public MapStorageData position(long position) {
        return (MapStorageData)super.position(position);
    }

    public native @Cast("uint16_t*") @StdVector ShortPointer y_begin(); public native MapStorageData y_begin(ShortPointer y_begin);
    public native @Cast("uint16_t*") @StdVector ShortPointer y_end(); public native MapStorageData y_end(ShortPointer y_end);
    public native @Cast("uint64_t*") @StdVector LongPointer global_index(); public native MapStorageData global_index(LongPointer global_index);
    public native @Cast("uint16_t*") @StdVector ShortPointer z(); public native MapStorageData z(ShortPointer z);
    public native @Cast("uint16_t*") @StdVector ShortPointer x(); public native MapStorageData x(ShortPointer x);
    public native @Cast("uint8_t*") @StdVector BytePointer level(); public native MapStorageData level(BytePointer level);
    public native @Cast("uint16_t*") @StdVector ShortPointer number_gaps(); public native MapStorageData number_gaps(ShortPointer number_gaps);
}


// #endif

// Parsed from data_structures/APR/APRIterator.hpp

//
// Created by cheesema on 16.01.18.
//

// #ifndef PARTPLAY_APR_ITERATOR_NEW_HPP
// #define PARTPLAY_APR_ITERATOR_NEW_HPP

// #include "APRAccessStructures.hpp"

// #include "GenIterator.hpp"

public static class APRIterator extends GenIterator {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public APRIterator(Pointer p) { super(p); }


    
    ///
    public APRIterator(@ByRef APRAccess apr_access_) { super((Pointer)null); allocate(apr_access_); }
    private native void allocate(@ByRef APRAccess apr_access_);

    /////////////////////////
    /** Random access
     * 
    ///////////////////////// */

    public native @Cast("bool") boolean set_iterator_by_particle_cell(@ByRef ParticleCell random_particle_cell);
    public native @Cast("bool") boolean set_iterator_by_global_coordinate(float x,float y,float z);
    public native @Cast("bool") boolean find_neighbours_same_level(@Cast("const uint8_t") byte direction);

    public native @Cast("bool") boolean set_iterator_to_particle_next_particle();


    public native @Cast("uint64_t") long set_new_lzx(@Cast("const uint16_t") short level,@Cast("const uint16_t") short z,@Cast("const uint16_t") short x);

    public native @Cast("uint64_t") long set_new_lzxy(@Cast("const uint16_t") short level,@Cast("const uint16_t") short z,@Cast("const uint16_t") short x,@Cast("const uint16_t") short y);

    public native @Cast("bool") boolean find_neighbours_in_direction(@Cast("const uint8_t") byte direction);

    public native @Cast("bool") boolean set_neighbour_iterator(@ByRef APRIterator original_iterator, @Cast("const uint8_t") byte direction, @Cast("const uint8_t") byte index);

}

















//
//inline ParticleCell APRIterator::get_neigh_particle_cell(){
//    return this->neighbour_particle_cell;
//}















// #endif //PARTPLAY_APR_ITERATOR_NEW_HPP


// Parsed from data_structures/APR/GenIterator.hpp

//
// Created by cheesema on 29.06.18.
//

// #ifndef LIBAPR_GENITERATOR_HPP
// #define LIBAPR_GENITERATOR_HPP

@Opaque public static class APRAccess extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public APRAccess() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public APRAccess(Pointer p) { super(p); }
}

@NoOffset public static class GenIterator extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GenIterator(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public GenIterator(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public GenIterator position(long position) {
        return (GenIterator)super.position(position);
    }


    public native @Cast("uint64_t") long end_index(); public native GenIterator end_index(long end_index);

    public native @Cast("uint64_t") long total_number_particles();

    public native @Cast("uint64_t") long particles_level_begin(@Cast("const uint16_t") short level_);
    public native @Cast("uint64_t") long particles_level_end(@Cast("const uint16_t") short level_);

    public native @Cast("uint64_t") long particles_z_begin(@Cast("const uint16_t") short level_,@Cast("const uint64_t") long z_);
    public native @Cast("uint64_t") long particles_z_end(@Cast("const uint16_t") short level_,@Cast("const uint64_t") long z_);

    public native @Cast("uint64_t") long particles_zx_begin(@Cast("const uint16_t") short level_,@Cast("const uint64_t") long z_,@Cast("const uint64_t") long x_);
    public native @Cast("uint64_t") long particles_zx_end(@Cast("const uint16_t") short level_,@Cast("const uint64_t") long z_,@Cast("const uint64_t") long x_);

    public native @Cast("uint64_t") long particles_offset_end(@Cast("const uint16_t") short level,@Cast("const uint64_t") long offset);

    public native @Cast("uint16_t") short x();
    public native @Cast("uint16_t") short y();
    public native @Cast("uint16_t") short z();
    public native @Cast("uint16_t") short level();
    public native @Cast("uint64_t") long global_index();
    public native @Cast("uint64_t") @Name("operator uint64_t") long asLong();

    public native @ByVal ParticleCell get_neigh_particle_cell();

    public native @Cast("uint8_t") byte number_neighbours_in_direction(@Cast("const uint8_t") byte face);

    public native @Cast("unsigned int") int x_nearest_pixel();
    public native float x_global();
    public native @Cast("unsigned int") int y_nearest_pixel();
    public native float y_global();
    public native @Cast("unsigned int") int z_nearest_pixel();
    public native float z_global();

    public native @Cast("uint16_t") short level_min();
    public native @Cast("uint16_t") short level_max();

    public native @Cast("uint64_t") long spatial_index_x_max(@Cast("const unsigned int") int level);
    public native @Cast("uint64_t") long spatial_index_y_max(@Cast("const unsigned int") int level);
    public native @Cast("uint64_t") long spatial_index_z_max(@Cast("const unsigned int") int level);

//    unsigned long number_gaps(){
//        if(apr_access->gap_map.data[current_particle_cell.level][current_particle_cell.pc_offset].size() > 0) {
//            return apr_access->gap_map.data[current_particle_cell.level][current_particle_cell.pc_offset][0].map.size();
//        } else {
//            return 0;
//        }
//    }

    public native void set_neighbour_flag();

//    uint64_t current_gap_y_begin(){
//        return current_gap.iterator->first;
//    }
//
//    uint64_t current_gap_y_end(){
//        return current_gap.iterator->second.y_end;
//    }
//
//    uint64_t current_gap_index(){
//        return current_gap.iterator->second.global_index_begin_offset; //#fixme
//    }


    public GenIterator() { super((Pointer)null); allocate(); }
    private native void allocate();


}


// #include "APRAccess.hpp"



















































// #endif //LIBAPR_GENITERATOR_HPP


// Parsed from algorithm/LocalParticleCellSet.hpp

//
// Created by cheesema on 08.01.18.
//

// #ifndef PARTPLAY_LOCAL_PARTICLE_SET_HPP
// #define PARTPLAY_LOCAL_PARTICLE_SET_HPP

// #ifdef _MSC_VER
// #include <intrin.h>

// from https://github.com/llvm-mirror/libcxx/blob/9dcbb46826fd4d29b1485f25e8986d36019a6dca/include/support/win32/support.h#L106-L182
// (c) Copyright (c) 2009-2017 by the contributors listed in https://github.com/llvm-mirror/libcxx/blob/9dcbb46826fd4d29b1485f25e8986d36019a6dca/CREDITS.TXT
// Returns the number of leading 0-bits in x, starting at the most significant
// bit position. If x is 0, the result is undefined.
public static native int __builtin_clzll(@Cast("unsigned long long") long mask);

public static native int __builtin_clzl(@Cast("unsigned long") long mask);

public static native int __builtin_clz(@Cast("unsigned int") int x);

// #endif

public static class LocalParticleCellSet extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public LocalParticleCellSet() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LocalParticleCellSet(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LocalParticleCellSet(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public LocalParticleCellSet position(long position) {
        return (LocalParticleCellSet)super.position(position);
    }

    public static native @Cast("uint32_t") int asmlog_2(@Cast("const uint32_t") int x);
}


// #endif //PARTPLAY_LOCAL_PARTICLE_SET_HPP


// Parsed from data_structures/Mesh/PixelData.hpp

//////////////////////////////////////////////////////////////
//
//
//  ImageGen 2016 Bevan Cheeseman
//                Krzysztof Gonciarz
//  Meshdata class for storing the image/pixel/mesh data
//
//
///////////////////////////////////////////////////////////////

// #ifndef PIXEL_DATA_HPP
// #define PIXEL_DATA_HPP

// #include <vector>
// #include <cmath>
// #include <memory>
// #include <sstream>
// #include <iostream>
// #include <iomanip>
// #include <algorithm>

// #include "misc/APRTimer.hpp"

// #ifdef HAVE_OPENMP
// #include <omp.h>
// #endif
// #ifdef APR_USE_CUDA
// #include "misc/CudaMemory.cuh"
// #endif


/**
 * Provides implementation for 3D mesh with elements of given type.
 * \tparam T type of mesh elements
 */

// #endif //PIXEL_DATA_HPP


}
